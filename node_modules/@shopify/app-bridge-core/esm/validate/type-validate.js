const TYPE_ERROR = 'type_error_expected';
function composeSchemas(...validators) {
    return (val) => {
        let error;
        let i = 0;
        const len = validators.length;
        while (!error && i < len) {
            error = validators[i](val);
            if (error) {
                return error;
            }
            i++;
        }
    };
}
/**
 * Returns a validator that matches values in the given enum
 * @param type - enum to use for match values
 * @public
 */
function matchesEnum(types, options) {
    return (value) => {
        const values = Object.keys(types).map((key) => types[key]);
        const message = (options && options.message) || `expected:${values.map((val) => `\`${val}\``).join(' or ')}`;
        return values.includes(value)
            ? undefined
            : constructErrors(value, 'invalid_enum_value', { ...options, message });
    };
}
function matchesArray(validator, options) {
    return (value) => {
        if (!Array.isArray(value)) {
            return constructErrors(value, `${TYPE_ERROR}_array`, options);
        }
        if (!validator) {
            return;
        }
        let errors = [];
        value.forEach((val, key) => {
            const objectError = validator(val);
            if (objectError) {
                errors = errors.concat(objectError.map((error) => ({ ...error, path: `['${key}']${error.path || ''}` })));
            }
        });
        return errors.length ? errors : undefined;
    };
}
function oneOf(...validators) {
    return (val) => {
        const errors = [];
        for (const validator of validators) {
            const result = validator(val);
            if (result == null)
                return result;
            errors.push(...result);
        }
        return errors;
    };
}
function constructErrors(value, error, options = { message: undefined }) {
    return [
        {
            value,
            error,
            message: typeof options.message === 'function' ? options.message(error, value) : options.message,
        },
    ];
}
function getErrors(obj, validator, key) {
    const value = key ? obj[key] : obj;
    const path = key ? `['${key}']` : undefined;
    const error = validator(value);
    if (!error) {
        return;
    }
    return error.map((errorObj) => ({
        ...errorObj,
        path: `${path || ''}${errorObj.path || ''}` || undefined,
    }));
}
function matchesObject(schema, options) {
    return (val) => {
        if (typeof val !== 'object' || !val || Array.isArray(val)) {
            return constructErrors(val, `${TYPE_ERROR}_object`, options);
        }
        const flattened = Object.keys(schema).reduce((acc, key) => {
            return [...acc, ...(getErrors(val, schema[key], key) || [])];
        }, []);
        return flattened.length ? flattened : undefined;
    };
}
function matchesString(options) {
    return (value) => typeof value === 'string' ? undefined : constructErrors(value, `${TYPE_ERROR}_string`, options);
}
function makeOptional(validator) {
    return (value) => {
        if (value === undefined || value === null) {
            return undefined;
        }
        return validator(value);
    };
}
function matchesBoolean(options) {
    return (value) => typeof value === 'boolean'
        ? undefined
        : constructErrors(value, `${TYPE_ERROR}_boolean`, options);
}
function matchesPositiveInteger(options) {
    return (value) => !Number.isInteger(value) || value < 0
        ? constructErrors(value, `${TYPE_ERROR}_integer`, options)
        : undefined;
}
function validate(obj, validator) {
    return getErrors(obj, validator);
}

export { TYPE_ERROR, composeSchemas, getErrors, makeOptional, matchesArray, matchesBoolean, matchesEnum, matchesObject, matchesPositiveInteger, matchesString, oneOf, validate };
