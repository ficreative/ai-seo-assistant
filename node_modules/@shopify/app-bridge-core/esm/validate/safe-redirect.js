import { INTERNAL_PROTOCOL } from '../util/constants.js';

const FILE_URI_MATCH = /\/\/\//;
const INVALID_RELATIVE_URL = /[/\\][/\\]/;
const VALID_PROTOCOLS = ['https:', 'http:'];
const DUMMY_HOSTNAME = 'http://test.com';
function isSafe(redirectUrl, { allowedDomains = [], subdomains = [], matchPath, requireAbsolute, requireSSL, allowInternalProtocol, } = {}) {
    if (FILE_URI_MATCH.test(redirectUrl)) {
        return false;
    }
    if (redirectUrl.startsWith('/')) {
        if (allowedDomains.length > 0 || subdomains.length > 0 || requireAbsolute || requireSSL) {
            return false;
        }
        if (matchPath) {
            // Creating a new URL expands the pathname in case of things like `/a/../b`
            return pathMatches(new URL(redirectUrl, DUMMY_HOSTNAME), redirectUrl, matchPath);
        }
        return !INVALID_RELATIVE_URL.test(redirectUrl);
    }
    let url;
    try {
        url = new URL(redirectUrl);
    }
    catch (error) {
        return false;
    }
    if (allowInternalProtocol && url.protocol === INTERNAL_PROTOCOL) {
        return true;
    }
    if (!VALID_PROTOCOLS.includes(url.protocol)) {
        return false;
    }
    if (requireSSL && url.protocol !== 'https:') {
        return false;
    }
    if (url.username || url.password) {
        return false;
    }
    if (matchPath && !pathMatches(url, redirectUrl, matchPath)) {
        return false;
    }
    if (!hostIsValid(url, allowedDomains, subdomains)) {
        return false;
    }
    return true;
}
function hostIsValid(url, allowedDomains, subdomains) {
    if (!subdomains.every((subdomain) => subdomain.startsWith('.'))) {
        throw new TypeError('Subdomains must begin with .');
    }
    const { hostname } = url;
    return ((allowedDomains.length === 0 && subdomains.length === 0) ||
        allowedDomains.includes(hostname) ||
        subdomains.some((subdomain) => hostname.endsWith(subdomain)));
}
function pathMatches(url, originalUrl, matcher) {
    const { pathname } = url;
    // Gets just the unresolve pathname, i.e., `http://foo.com/a/../b => /a/../b
    const originalPathname = originalUrl.replace(url.origin, '').split('?')[0];
    return typeof matcher === 'string'
        ? pathname === matcher && originalPathname === matcher
        : matcher.test(pathname) && matcher.test(originalPathname);
}

export { isSafe };
