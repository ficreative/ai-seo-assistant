import mergeProps from './merge.js';
import { PREFIX, SEPARATOR } from './constants.js';
import { Group } from './types.js';

function actionWrapper(action) {
    return action;
}
const NonSnakeCaseGroup = [
    Group.AuthCode,
    Group.Button,
    Group.ButtonGroup,
    Group.Cart,
    Group.Error,
    Group.Features,
    Group.Fullscreen,
    Group.Link,
    Group.Loading,
    Group.Menu,
    Group.Modal,
    Group.Navigation,
    Group.Pos,
    Group.Print,
    Group.ResourcePicker,
    Group.Scanner,
    Group.SessionToken,
    Group.Share,
    Group.TitleBar,
    Group.Toast,
    Group.unstable_Picker,
];
function camelCaseToSnakeCase(value) {
    return value.replace(/([A-Z])/g, (matcher, _val, index) => {
        return `${index === 0 ? '' : '_'}${matcher[0].toLowerCase()}`;
    });
}
/**
 * Maps the group name to its event name
 * @internal
 * @remarks - This method is necessary for the new pattern of using snake case
 * which makes it more readable and easier to reconstruct the group from an event name.
 * Example: `ContextualSaveBar` becomes `CONTEXTUAL_SAVE_BAR`
 * */
function groupToEventNameSpace(group) {
    if (NonSnakeCaseGroup.includes(group)) {
        return group.toUpperCase();
    }
    return camelCaseToSnakeCase(group).toUpperCase();
}
/**
 * Returns full event name with prefix, group, subgroups and type formatted with separators
 * @internal
 * */
function getEventNameSpace(group, eventName, component) {
    if (eventName.startsWith(`${PREFIX}${SEPARATOR}`)) {
        return eventName;
    }
    let eventNameSpace = groupToEventNameSpace(group);
    if (component) {
        const { subgroups, type } = component;
        if (subgroups && subgroups.length > 0) {
            eventNameSpace += eventNameSpace.length > 0 ? SEPARATOR : '';
            subgroups.forEach((subgroup, index) => {
                eventNameSpace += `${subgroup.toUpperCase()}${index < subgroups.length - 1 ? SEPARATOR : ''}`;
            });
        }
        if (type !== group && type) {
            eventNameSpace += `${eventNameSpace.length > 0 ? SEPARATOR : ''}${type.toUpperCase()}`;
        }
    }
    if (eventNameSpace) {
        eventNameSpace += `${eventNameSpace.length > 0 ? SEPARATOR : ''}${eventName.toUpperCase()}`;
    }
    return `${PREFIX}${SEPARATOR}${eventNameSpace}`;
}
function findMatchInEnum(types, lookup) {
    const match = Object.keys(types).find((key) => {
        return lookup === types[key];
    });
    return match ? types[match] : undefined;
}
function getMergedProps(props, newProps) {
    const merged = mergeProps(props, newProps);
    if (!merged) {
        // tslint:disable-next-line:prefer-object-spread
        const cloned = Object.assign(props, newProps);
        return cloned;
    }
    return merged;
}
function forEachInEnum(types, callback) {
    Object.keys(types).forEach((key) => {
        callback(types[key]);
    });
}
function isValidOptionalNumber(value) {
    return value === null || value === undefined || typeof value === 'number';
}
function isValidOptionalString(value) {
    return value === null || value === undefined || typeof value === 'string';
}
function updateActionFromPayload(action, newProps) {
    const { id } = action;
    if (id === newProps.id) {
        // Merge new properties
        Object.assign(action, getMergedProps(action, newProps));
        return true;
    }
    return false;
}

export { NonSnakeCaseGroup, actionWrapper, findMatchInEnum, forEachInEnum, getEventNameSpace, getMergedProps, isValidOptionalNumber, isValidOptionalString, updateActionFromPayload };
