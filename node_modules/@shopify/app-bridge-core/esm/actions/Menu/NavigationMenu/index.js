import { Action as Action$1 } from '../../Link/AppLink/index.js';
import { actionWrapper, getMergedProps, updateActionFromPayload } from '../../helper.js';
import { ActionSetWithChildren } from '../../ActionSet.js';
import { Group } from '../../types.js';

const SUBGROUPS = ['Navigation_Menu'];
var Action;
(function (Action) {
    Action["UPDATE"] = "APP::MENU::NAVIGATION_MENU::UPDATE";
    Action["LINK_UPDATE"] = "APP::MENU::NAVIGATION_MENU::LINK::UPDATE";
})(Action || (Action = {}));
function update(payload) {
    return actionWrapper({
        payload,
        group: Group.Menu,
        type: Action.UPDATE,
    });
}
class NavigationMenu extends ActionSetWithChildren {
    items = [];
    active;
    itemsOptions;
    activeOptions;
    constructor(app, options) {
        super(app, 'Navigation_Menu', Group.Menu);
        // Trigger 'update' on creation
        this.set(options);
    }
    get options() {
        return {
            items: this.itemsOptions,
            active: this.activeOptions,
        };
    }
    get payload() {
        return {
            ...this.options,
            active: this.active,
            items: this.items,
            id: this.id,
        };
    }
    set(options, shouldUpdate = true) {
        const mergedOptions = getMergedProps(this.options, options);
        const { items, active } = mergedOptions;
        this.setItems(items);
        this.activeOptions = active;
        this.active = active && active.id;
        if (shouldUpdate) {
            this.dispatch(Action.UPDATE);
        }
        return this;
    }
    dispatch(action) {
        switch (action) {
            case Action.UPDATE:
                this.app.dispatch(update(this.payload));
                break;
        }
        return this;
    }
    updateItem(newPayload) {
        if (!this.items) {
            return;
        }
        const itemToUpdate = this.items.find((action) => action.id === newPayload.id);
        if (!itemToUpdate) {
            return;
        }
        if (updateActionFromPayload(itemToUpdate, newPayload)) {
            this.dispatch(Action.UPDATE);
        }
    }
    setItems(newOptions) {
        const newItems = newOptions || [];
        const currentItems = this.itemsOptions || [];
        this.itemsOptions = this.getUpdatedChildActions(newItems, currentItems);
        this.items = this.itemsOptions
            ? this.itemsOptions.map((action) => {
                this.addChild(action, this.group, SUBGROUPS);
                this.subscribeToChild(action, Action$1.UPDATE, this.updateItem);
                return action.payload;
            })
            : [];
    }
}

export { Action, NavigationMenu, update };
