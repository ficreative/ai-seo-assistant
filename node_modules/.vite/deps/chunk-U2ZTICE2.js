import {
  HashFormat,
  addHeader,
  getHeader,
  getHeaders,
  removeHeader
} from "./chunk-SOIE5ZGB.js";

// node_modules/@shopify/shopify-api/dist/esm/lib/error.mjs
var ShopifyError = class extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
var InvalidHmacError = class extends ShopifyError {
};
var InvalidShopError = class extends ShopifyError {
};
var InvalidHostError = class extends ShopifyError {
};
var InvalidJwtError = class extends ShopifyError {
};
var MissingJwtTokenError = class extends ShopifyError {
};
var InvalidDeliveryMethodError = class extends ShopifyError {
};
var SafeCompareError = class extends ShopifyError {
};
var PrivateAppError = class extends ShopifyError {
};
var HttpRequestError = class extends ShopifyError {
};
var HttpMaxRetriesError = class extends ShopifyError {
};
var HttpResponseError = class extends ShopifyError {
  response;
  constructor({ message, code, statusText, body, headers }) {
    super(message);
    this.response = {
      code,
      statusText,
      body,
      headers
    };
  }
};
var HttpRetriableError = class extends HttpResponseError {
};
var HttpInternalError = class extends HttpRetriableError {
};
var HttpThrottlingError = class extends HttpRetriableError {
  constructor({ retryAfter, ...params }) {
    super(params);
    this.response.retryAfter = retryAfter;
  }
};
var RestResourceError = class extends ShopifyError {
};
var GraphqlQueryError = class extends ShopifyError {
  response;
  headers;
  body;
  constructor({ message, response, headers, body }) {
    super(message);
    this.response = response;
    this.headers = headers;
    this.body = body;
  }
};
var InvalidOAuthError = class extends ShopifyError {
};
var BotActivityDetected = class extends ShopifyError {
};
var CookieNotFound = class extends ShopifyError {
};
var InvalidSession = class extends ShopifyError {
};
var InvalidWebhookError = class extends ShopifyError {
  response;
  constructor({ message, response }) {
    super(message);
    this.response = response;
  }
};
var MissingWebhookCallbackError = class extends InvalidWebhookError {
};
var SessionStorageError = class extends ShopifyError {
};
var MissingRequiredArgument = class extends ShopifyError {
};
var UnsupportedClientType = class extends ShopifyError {
};
var InvalidRequestError = class extends ShopifyError {
};
var BillingError = class extends ShopifyError {
  errorData;
  constructor({ message, errorData }) {
    super(message);
    this.errorData = errorData;
  }
};
var FeatureDeprecatedError = class extends ShopifyError {
};

// node_modules/@shopify/shopify-api/dist/esm/runtime/crypto/utils.mjs
async function createSHA256HMAC(secret, payload, returnFormat = HashFormat.Base64) {
  const cryptoLib = typeof crypto?.webcrypto === "undefined" ? crypto : crypto.webcrypto;
  const enc = new TextEncoder();
  const key = await cryptoLib.subtle.importKey("raw", enc.encode(secret), {
    name: "HMAC",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const signature = await cryptoLib.subtle.sign("HMAC", key, enc.encode(payload));
  return returnFormat === HashFormat.Base64 ? asBase64(signature) : asHex(signature);
}
function asHex(buffer) {
  return [...new Uint8Array(buffer)].map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
var LookupTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function asBase64(buffer) {
  let output = "";
  const input = new Uint8Array(buffer);
  for (let i = 0; i < input.length; ) {
    const byte1 = input[i++];
    const byte2 = input[i++];
    const byte3 = input[i++];
    const enc1 = byte1 >> 2;
    const enc2 = (byte1 & 3) << 4 | byte2 >> 4;
    let enc3 = (byte2 & 15) << 2 | byte3 >> 6;
    let enc4 = byte3 & 63;
    if (isNaN(byte2)) {
      enc3 = 64;
    }
    if (isNaN(byte3)) {
      enc4 = 64;
    }
    output += LookupTable[enc1] + LookupTable[enc2] + LookupTable[enc3] + LookupTable[enc4];
  }
  return output;
}
function hashString(str, returnFormat) {
  const buffer = new TextEncoder().encode(str);
  switch (returnFormat) {
    case HashFormat.Base64:
      return asBase64(buffer);
    case HashFormat.Hex:
      return asHex(buffer);
    default:
      throw new ShopifyError(`Unrecognized hash format '${returnFormat}'`);
  }
}

// node_modules/@shopify/shopify-api/dist/esm/runtime/http/utils.mjs
function splitN(str, sep, maxNumParts) {
  const parts = str.split(sep);
  const maxParts = Math.min(Math.abs(maxNumParts), parts.length);
  return [...parts.slice(0, maxParts - 1), parts.slice(maxParts - 1).join(sep)];
}

// node_modules/@shopify/shopify-api/dist/esm/runtime/http/cookies.mjs
var Cookies = class _Cookies {
  response;
  static parseCookies(hdrs) {
    const entries = hdrs.filter((hdr) => hdr.trim().length > 0).map((cookieDef) => {
      const [keyval, ...opts] = cookieDef.split(";");
      const [name, value] = splitN(keyval, "=", 2).map((value2) => value2.trim());
      return [
        name,
        {
          name,
          value,
          ...Object.fromEntries(opts.map((opt) => splitN(opt, "=", 2).map((value2) => value2.trim())))
        }
      ];
    });
    const jar = Object.fromEntries(entries);
    for (const cookie of Object.values(jar)) {
      if (typeof cookie.expires === "string") {
        cookie.expires = new Date(cookie.expires);
      }
    }
    return jar;
  }
  static encodeCookie(data) {
    let result = "";
    result += `${data.name}=${data.value};`;
    result += Object.entries(data).filter(([key]) => !["name", "value", "expires"].includes(key)).map(([key, value]) => `${key}=${value}`).join("; ");
    if (data.expires) {
      result += ";";
      result += `expires=${data.expires.toUTCString()}`;
    }
    return result;
  }
  receivedCookieJar = {};
  outgoingCookieJar = {};
  keys = [];
  constructor(request, response, { keys = [] } = {}) {
    this.response = response;
    if (keys)
      this.keys = keys;
    const cookieReqHdr = getHeader(request.headers, "Cookie") ?? "";
    this.receivedCookieJar = _Cookies.parseCookies(cookieReqHdr.split(";"));
    const cookieResHdr = getHeaders(response.headers, "Set-Cookie") ?? [];
    this.outgoingCookieJar = _Cookies.parseCookies(cookieResHdr);
  }
  toHeaders() {
    return Object.values(this.outgoingCookieJar).map((cookie) => _Cookies.encodeCookie(cookie));
  }
  updateHeader() {
    if (!this.response.headers) {
      this.response.headers = {};
    }
    removeHeader(this.response.headers, "Set-Cookie");
    this.toHeaders().map((hdr) => addHeader(this.response.headers, "Set-Cookie", hdr));
  }
  get(name) {
    return this.receivedCookieJar[name]?.value;
  }
  deleteCookie(name) {
    this.set(name, "", {
      path: "/",
      expires: /* @__PURE__ */ new Date(0)
    });
  }
  async getAndVerify(name) {
    const value = this.get(name);
    if (!value)
      return void 0;
    if (!await this.isSignedCookieValid(name)) {
      return void 0;
    }
    return value;
  }
  get canSign() {
    return this.keys?.length > 0;
  }
  set(name, value, opts = {}) {
    this.outgoingCookieJar[name] = {
      ...opts,
      name,
      value
    };
    this.updateHeader();
  }
  async setAndSign(name, value, opts = {}) {
    if (!this.canSign) {
      throw Error("No keys provided for signing.");
    }
    this.set(name, value, opts);
    const sigName = `${name}.sig`;
    const signature = await createSHA256HMAC(this.keys[0], value);
    this.set(sigName, signature, opts);
    this.updateHeader();
  }
  async isSignedCookieValid(cookieName) {
    const signedCookieName = `${cookieName}.sig`;
    if (!this.cookieExists(cookieName) || !this.cookieExists(signedCookieName)) {
      this.deleteInvalidCookies(cookieName, signedCookieName);
      return false;
    }
    const cookieValue = this.get(cookieName);
    const signature = this.get(signedCookieName);
    if (!cookieValue || !signature) {
      this.deleteInvalidCookies(cookieName, signedCookieName);
      return false;
    }
    const allCheckSignatures = await Promise.all(this.keys.map((key) => createSHA256HMAC(key, cookieValue)));
    if (!allCheckSignatures.includes(signature)) {
      this.deleteInvalidCookies(cookieName, signedCookieName);
      return false;
    }
    return true;
  }
  cookieExists(cookieName) {
    return Boolean(this.get(cookieName));
  }
  deleteInvalidCookies(...cookieNames) {
    cookieNames.forEach((cookieName) => this.deleteCookie(cookieName));
  }
};

export {
  ShopifyError,
  InvalidHmacError,
  InvalidShopError,
  InvalidHostError,
  InvalidJwtError,
  MissingJwtTokenError,
  InvalidDeliveryMethodError,
  SafeCompareError,
  PrivateAppError,
  HttpRequestError,
  HttpMaxRetriesError,
  HttpResponseError,
  HttpRetriableError,
  HttpInternalError,
  HttpThrottlingError,
  RestResourceError,
  GraphqlQueryError,
  InvalidOAuthError,
  BotActivityDetected,
  CookieNotFound,
  InvalidSession,
  InvalidWebhookError,
  MissingWebhookCallbackError,
  SessionStorageError,
  MissingRequiredArgument,
  UnsupportedClientType,
  InvalidRequestError,
  BillingError,
  FeatureDeprecatedError,
  createSHA256HMAC,
  asHex,
  asBase64,
  hashString,
  splitN,
  Cookies
};
//# sourceMappingURL=chunk-U2ZTICE2.js.map
