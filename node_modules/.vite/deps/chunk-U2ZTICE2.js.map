{
  "version": 3,
  "sources": ["../../lib/error.ts", "../../runtime/crypto/utils.ts", "../../runtime/http/utils.ts", "../../runtime/http/cookies.ts"],
  "sourcesContent": ["import {AdapterResponse} from '../runtime/http/types';\n\nexport class ShopifyError extends Error {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\nexport class InvalidHmacError extends ShopifyError {}\nexport class InvalidShopError extends ShopifyError {}\nexport class InvalidHostError extends ShopifyError {}\nexport class InvalidJwtError extends ShopifyError {}\nexport class MissingJwtTokenError extends ShopifyError {}\nexport class InvalidDeliveryMethodError extends ShopifyError {}\n\nexport class SafeCompareError extends ShopifyError {}\nexport class PrivateAppError extends ShopifyError {}\n\nexport class HttpRequestError extends ShopifyError {}\nexport class HttpMaxRetriesError extends ShopifyError {}\n\ninterface HttpResponseData {\n  code: number;\n  statusText: string;\n  body?: Record<string, unknown>;\n  headers?: Record<string, unknown>;\n}\n\ninterface HttpResponseErrorParams extends HttpResponseData {\n  message: string;\n}\nexport class HttpResponseError<\n  ResponseType extends HttpResponseData = HttpResponseData,\n> extends ShopifyError {\n  readonly response: ResponseType;\n\n  constructor({\n    message,\n    code,\n    statusText,\n    body,\n    headers,\n  }: HttpResponseErrorParams) {\n    super(message);\n    this.response = {\n      code,\n      statusText,\n      body,\n      headers,\n    } as ResponseType;\n  }\n}\nexport class HttpRetriableError<\n  ResponseType extends HttpResponseData = HttpResponseData,\n> extends HttpResponseError<ResponseType> {}\nexport class HttpInternalError extends HttpRetriableError {}\n\ninterface HttpThrottlingErrorData extends HttpResponseData {\n  retryAfter?: number;\n}\ninterface HttpThrottlingErrorParams extends HttpThrottlingErrorData {\n  message: string;\n}\nexport class HttpThrottlingError extends HttpRetriableError<HttpThrottlingErrorData> {\n  constructor({retryAfter, ...params}: HttpThrottlingErrorParams) {\n    super(params);\n    this.response.retryAfter = retryAfter;\n  }\n}\n\nexport class RestResourceError extends ShopifyError {}\n\ninterface GraphqlQueryErrorParams {\n  message: string;\n  response: Record<string, unknown>;\n  headers?: Record<string, unknown>;\n  body?: Record<string, any>;\n}\n\nexport class GraphqlQueryError extends ShopifyError {\n  readonly response: Record<string, unknown>;\n  readonly headers?: Record<string, unknown>;\n  readonly body?: Record<string, any>;\n\n  constructor({message, response, headers, body}: GraphqlQueryErrorParams) {\n    super(message);\n    this.response = response;\n    this.headers = headers;\n    this.body = body;\n  }\n}\n\nexport class InvalidOAuthError extends ShopifyError {}\nexport class BotActivityDetected extends ShopifyError {}\nexport class CookieNotFound extends ShopifyError {}\nexport class InvalidSession extends ShopifyError {}\n\ninterface InvalidWebhookParams {\n  message: string;\n  response: AdapterResponse;\n}\nexport class InvalidWebhookError extends ShopifyError {\n  readonly response: AdapterResponse;\n\n  constructor({message, response}: InvalidWebhookParams) {\n    super(message);\n    this.response = response;\n  }\n}\nexport class MissingWebhookCallbackError extends InvalidWebhookError {}\nexport class SessionStorageError extends ShopifyError {}\nexport class MissingRequiredArgument extends ShopifyError {}\nexport class UnsupportedClientType extends ShopifyError {}\nexport class InvalidRequestError extends ShopifyError {}\ninterface BillingErrorParams {\n  message: string;\n  errorData: any;\n}\nexport class BillingError extends ShopifyError {\n  readonly errorData: any;\n\n  constructor({message, errorData}: BillingErrorParams) {\n    super(message);\n    this.errorData = errorData;\n  }\n}\nexport class FeatureDeprecatedError extends ShopifyError {}\n", "import {ShopifyError} from '../../lib/error';\n\nimport {HashFormat} from './types';\n\nexport async function createSHA256HMAC(\n  secret: string,\n  payload: string,\n  returnFormat: HashFormat = HashFormat.Base64,\n): Promise<string> {\n  const cryptoLib =\n    typeof (crypto as any)?.webcrypto === 'undefined'\n      ? crypto\n      : (crypto as any).webcrypto;\n\n  const enc = new TextEncoder();\n  const key = await cryptoLib.subtle.importKey(\n    'raw',\n    enc.encode(secret),\n    {\n      name: 'HMAC',\n      hash: {name: 'SHA-256'},\n    },\n    false,\n    ['sign'],\n  );\n\n  const signature = await cryptoLib.subtle.sign(\n    'HMAC',\n    key,\n    enc.encode(payload),\n  );\n  return returnFormat === HashFormat.Base64\n    ? asBase64(signature)\n    : asHex(signature);\n}\n\nexport function asHex(buffer: ArrayBuffer): string {\n  return [...new Uint8Array(buffer)]\n    .map((byte) => byte.toString(16).padStart(2, '0'))\n    .join('');\n}\n\nconst LookupTable =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nexport function asBase64(buffer: ArrayBuffer): string {\n  let output = '';\n\n  const input = new Uint8Array(buffer);\n  for (let i = 0; i < input.length; ) {\n    const byte1 = input[i++];\n    const byte2 = input[i++];\n    const byte3 = input[i++];\n\n    const enc1 = byte1 >> 2;\n    const enc2 = ((byte1 & 0b00000011) << 4) | (byte2 >> 4);\n    let enc3 = ((byte2 & 0b00001111) << 2) | (byte3 >> 6);\n    let enc4 = byte3 & 0b00111111;\n\n    if (isNaN(byte2)) {\n      enc3 = 64;\n    }\n    if (isNaN(byte3)) {\n      enc4 = 64;\n    }\n\n    output +=\n      LookupTable[enc1] +\n      LookupTable[enc2] +\n      LookupTable[enc3] +\n      LookupTable[enc4];\n  }\n  return output;\n}\n\nexport function hashString(str: string, returnFormat: HashFormat): string {\n  const buffer = new TextEncoder().encode(str);\n\n  switch (returnFormat) {\n    case HashFormat.Base64:\n      return asBase64(buffer);\n    case HashFormat.Hex:\n      return asHex(buffer);\n    default:\n      throw new ShopifyError(`Unrecognized hash format '${returnFormat}'`);\n  }\n}\n", "export function splitN(\n  str: string,\n  sep: string,\n  maxNumParts: number,\n): string[] {\n  const parts = str.split(sep);\n  const maxParts = Math.min(Math.abs(maxNumParts), parts.length);\n\n  return [...parts.slice(0, maxParts - 1), parts.slice(maxParts - 1).join(sep)];\n}\n", "// import type {Headers} from \"./headers\";\nimport {createSHA256HMAC} from '../crypto/utils';\n\nimport {splitN} from './utils';\nimport {getHeader, getHeaders, removeHeader, addHeader} from './headers';\n\nimport type {NormalizedRequest, NormalizedResponse} from '.';\n\nexport interface CookieData {\n  name: string;\n  value: string;\n  /**\n   * a number representing the milliseconds from Date.now() for expiry\n   */\n  maxAge?: number;\n  /**\n   * a Date object indicating the cookie's expiration\n   * date (expires at the end of session by default).\n   */\n  expires?: Date;\n  /**\n   * a string indicating the path of the cookie (/ by default).\n   */\n  path?: string;\n  /**\n   * a string indicating the domain of the cookie (no default).\n   */\n  domain?: string;\n  /**\n   * a boolean indicating whether the cookie is only to be sent\n   * over HTTPS (false by default for HTTP, true by default for HTTPS).\n   */\n  secure?: boolean;\n  /**\n   * a boolean indicating whether the cookie is only to be sent over HTTP(S),\n   * and not made available to client JavaScript (true by default).\n   */\n  httpOnly?: boolean;\n  /**\n   * a boolean or string indicating whether the cookie is a \"same site\" cookie (false by default).\n   * This can be set to 'strict', 'lax', or true (which maps to 'strict').\n   */\n  sameSite?: 'strict' | 'lax' | 'none';\n}\n\nexport type CookieJar = Record<string, CookieData>;\ninterface CookiesOptions {\n  keys: string[];\n  // Ignored. Only for type-compatibility with the node package for now.\n  secure: boolean;\n}\nexport class Cookies {\n  static parseCookies(hdrs: string[]): CookieJar {\n    const entries = hdrs\n      .filter((hdr) => hdr.trim().length > 0)\n      .map((cookieDef) => {\n        const [keyval, ...opts] = cookieDef.split(';');\n        const [name, value] = splitN(keyval, '=', 2).map((value) =>\n          value.trim(),\n        );\n        return [\n          name,\n          {\n            name,\n            value,\n            ...Object.fromEntries(\n              opts.map((opt) =>\n                splitN(opt, '=', 2).map((value) => value.trim()),\n              ),\n            ),\n          },\n        ];\n      });\n    const jar = Object.fromEntries(entries) as CookieJar;\n    for (const cookie of Object.values(jar)) {\n      if (typeof cookie.expires === 'string') {\n        cookie.expires = new Date(cookie.expires);\n      }\n    }\n    return jar;\n  }\n\n  static encodeCookie(data: CookieData): string {\n    let result = '';\n    result += `${data.name}=${data.value};`;\n    result += Object.entries(data)\n      .filter(([key]) => !['name', 'value', 'expires'].includes(key))\n      .map(([key, value]) => `${key}=${value}`)\n      .join('; ');\n    if (data.expires) {\n      result += ';';\n      result += `expires=${data.expires.toUTCString()}`;\n    }\n    return result;\n  }\n\n  receivedCookieJar: CookieJar = {};\n  outgoingCookieJar: CookieJar = {};\n  private keys: string[] = [];\n\n  constructor(\n    request: NormalizedRequest,\n    public response: NormalizedResponse,\n    {keys = []}: Partial<CookiesOptions> = {},\n  ) {\n    if (keys) this.keys = keys;\n\n    const cookieReqHdr = getHeader(request.headers, 'Cookie') ?? '';\n    this.receivedCookieJar = Cookies.parseCookies(cookieReqHdr.split(';'));\n    const cookieResHdr = getHeaders(response.headers, 'Set-Cookie') ?? [];\n    this.outgoingCookieJar = Cookies.parseCookies(cookieResHdr);\n  }\n\n  toHeaders(): string[] {\n    return Object.values(this.outgoingCookieJar).map((cookie) =>\n      Cookies.encodeCookie(cookie),\n    );\n  }\n\n  updateHeader() {\n    if (!this.response.headers) {\n      this.response.headers = {};\n    }\n    removeHeader(this.response.headers, 'Set-Cookie');\n    this.toHeaders().map((hdr) =>\n      addHeader(this.response.headers!, 'Set-Cookie', hdr),\n    );\n  }\n\n  get(name: string): string | undefined {\n    return this.receivedCookieJar[name]?.value;\n  }\n\n  deleteCookie(name: string) {\n    this.set(name, '', {\n      path: '/',\n      expires: new Date(0),\n    });\n  }\n\n  async getAndVerify(name: string): Promise<string | undefined> {\n    const value = this.get(name);\n    if (!value) return undefined;\n    if (!(await this.isSignedCookieValid(name))) {\n      return undefined;\n    }\n    return value;\n  }\n\n  private get canSign() {\n    return this.keys?.length > 0;\n  }\n\n  set(name: string, value: string, opts: Partial<CookieData> = {}): void {\n    this.outgoingCookieJar[name] = {\n      ...opts,\n      name,\n      value,\n    };\n    this.updateHeader();\n  }\n\n  async setAndSign(\n    name: string,\n    value: string,\n    opts: Partial<CookieData> = {},\n  ): Promise<void> {\n    if (!this.canSign) {\n      throw Error('No keys provided for signing.');\n    }\n    this.set(name, value, opts);\n    const sigName = `${name}.sig`;\n    const signature = await createSHA256HMAC(this.keys[0], value);\n    this.set(sigName, signature, opts);\n    this.updateHeader();\n  }\n\n  async isSignedCookieValid(cookieName: string): Promise<boolean> {\n    const signedCookieName = `${cookieName}.sig`;\n    if (\n      !this.cookieExists(cookieName) ||\n      !this.cookieExists(signedCookieName)\n    ) {\n      this.deleteInvalidCookies(cookieName, signedCookieName);\n      return false;\n    }\n    const cookieValue = this.get(cookieName);\n    const signature = this.get(signedCookieName);\n\n    if (!cookieValue || !signature) {\n      this.deleteInvalidCookies(cookieName, signedCookieName);\n      return false;\n    }\n\n    const allCheckSignatures = await Promise.all(\n      this.keys.map((key) => createSHA256HMAC(key, cookieValue)),\n    );\n\n    if (!allCheckSignatures.includes(signature)) {\n      this.deleteInvalidCookies(cookieName, signedCookieName);\n      return false;\n    }\n\n    return true;\n  }\n\n  private cookieExists(cookieName: string) {\n    return Boolean(this.get(cookieName));\n  }\n\n  private deleteInvalidCookies(...cookieNames: string[]): void {\n    cookieNames.forEach((cookieName) => this.deleteCookie(cookieName));\n  }\n}\n"],
  "mappings": "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",
  "names": ["value"]
}
