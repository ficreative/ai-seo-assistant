{
  "version": 3,
  "sources": ["../../runtime/platform/runtime-string.ts", "../../runtime/http/headers.ts", "../../runtime/crypto/types.ts", "../../runtime/http/index.ts"],
  "sourcesContent": ["import {AbstractRuntimeStringFunc} from './types';\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractRuntimeString: AbstractRuntimeStringFunc = () => {\n  throw new Error(\n    \"Missing adapter implementation for 'abstractRuntimeString' - make sure to import the appropriate adapter for your platform\",\n  );\n};\nexport function setAbstractRuntimeString(func: AbstractRuntimeStringFunc) {\n  abstractRuntimeString = func;\n}\n", "import type {Headers} from './types';\n\n/**\n * Canonicalizes a header name by capitalizing each segment and ensuring consistent hyphenation.\n *\n * @param hdr - The header name to canonicalize.\n * @returns The canonicalized header name.\n */\nexport function canonicalizeHeaderName(hdr: string): string {\n  return hdr.replace(\n    /(^|-)(\\w+)/g,\n    (_fullMatch, start, letters) =>\n      start +\n      letters.slice(0, 1).toUpperCase() +\n      letters.slice(1).toLowerCase(),\n  );\n}\n\n/**\n * Retrieves all values associated with a canonicalized header name from the headers object.\n *\n * @param headers - The headers object or undefined.\n * @param needle_ - The header name to search for.\n * @returns An array of header values associated with the canonicalized header name.\n */\nexport function getHeaders(\n  headers: Headers | undefined,\n  needle_: string,\n): string[] {\n  const result: string[] = [];\n  if (!headers) return result;\n  const needle = canonicalizeHeaderName(needle_);\n  for (const [key, values] of Object.entries(headers)) {\n    if (canonicalizeHeaderName(key) !== needle) continue;\n    if (Array.isArray(values)) {\n      result.push(...values);\n    } else {\n      result.push(values);\n    }\n  }\n  return result;\n}\n\n/**\n * Retrieves the first value associated with a canonicalized header name from the headers object.\n *\n * @param headers - The headers object or undefined.\n * @param needle - The header name to search for.\n * @returns The first value associated with the canonicalized header name, or undefined if not found.\n */\nexport function getHeader(\n  headers: Headers | undefined,\n  needle: string,\n): string | undefined {\n  if (!headers) return undefined;\n  return getHeaders(headers, needle)?.[0];\n}\n/**\n * Sets a header to a single value, canonicalizing the header name.\n *\n * @param headers - The headers object.\n * @param key - The header name to set.\n * @param value - The value to assign to the header.\n */\nexport function setHeader(headers: Headers, key: string, value: string) {\n  canonicalizeHeaders(headers);\n  headers[canonicalizeHeaderName(key)] = [value];\n}\n/**\n * Adds a value to an existing header, creating a new array if necessary, and canonicalizing the header name.\n *\n * @param headers - The headers object.\n * @param key - The header name to add to.\n * @param value - The value to add.\n */\nexport function addHeader(headers: Headers, key: string, value: string) {\n  canonicalizeHeaders(headers);\n  const canonKey = canonicalizeHeaderName(key);\n  let list = headers[canonKey];\n  if (!list) {\n    list = [];\n  } else if (!Array.isArray(list)) {\n    list = [list];\n  }\n  headers[canonKey] = list;\n  list.push(value);\n}\n\n/**\n * Canonicalizes a header value, converting numbers to strings.\n *\n * @param value - The value to canonicalize.\n * @returns The canonicalized value as a string.\n */\nfunction canonicalizeValue(value: any): any {\n  if (typeof value === 'number') return value.toString();\n  return value;\n}\n\n/**\n * Canonicalizes all headers in the headers object by ensuring consistent header names and values.\n *\n * @param hdr - The headers object to canonicalize.\n * @returns The headers object with canonicalized header names and values.\n */\nexport function canonicalizeHeaders(hdr: Headers): Headers {\n  for (const [key, values] of Object.entries(hdr)) {\n    const canonKey = canonicalizeHeaderName(key);\n    if (!hdr[canonKey]) hdr[canonKey] = [];\n    if (!Array.isArray(hdr[canonKey]))\n      hdr[canonKey] = [canonicalizeValue(hdr[canonKey])];\n    if (key === canonKey) continue;\n    delete hdr[key];\n    (hdr[canonKey] as any).push(\n      ...[values].flat().map((value) => canonicalizeValue(value)),\n    );\n  }\n  return hdr;\n}\n\n/**\n * Removes a header from the headers object.\n *\n * @param headers - The headers object.\n * @param needle - The header name to remove.\n */\nexport function removeHeader(headers: Headers, needle: string) {\n  canonicalizeHeaders(headers);\n  const canonKey = canonicalizeHeaderName(needle);\n  delete headers[canonKey];\n}\n\n/**\n * Converts a headers object into an array of tuples, where each tuple represents a header name and value.\n *\n * @param {Object|string[][]} headers - The headers object or undefined/null.\n * @returns {string[][]} An array of tuples where each tuple contains a header name and its corresponding value.\n *\n * @example\n * // Example headers object\n * const headers = {\n *   'Set-Cookie': 'a=b',\n *   'Set-Cookie': 'x=y'\n * };\n *\n * // Converted to an array of tuples\n * const result = convertHeadersToTuples(headers);\n * console.log(result);\n * // Output: [\n * //   [\"Set-Cookie\", \"a=b\"],\n * //   [\"Set-Cookie\", \"x=y\"]\n * // ]\n */\nexport function flatHeaders(\n  headers: Headers | undefined | null,\n): [string, string][] {\n  if (!headers) return [];\n\n  return Object.entries(headers).flatMap(([header, values]) =>\n    Array.isArray(values)\n      ? values.map((value): [string, string] => [header, value])\n      : [[header, values]],\n  );\n}\n", "export enum HashFormat {\n  Base64 = 'base64',\n  Hex = 'hex',\n}\n", "import type {\n  AbstractFetchFunc,\n  AbstractConvertRequestFunc,\n  AbstractConvertIncomingResponseFunc,\n  AbstractConvertResponseFunc,\n  NormalizedResponse,\n  AbstractConvertHeadersFunc,\n} from './types';\n\nexport * from './cookies';\nexport * from './headers';\nexport * from './utils';\n\nexport * from './types';\n\nexport function isOK(resp: NormalizedResponse) {\n  // https://fetch.spec.whatwg.org/#ok-status\n  return resp.statusCode >= 200 && resp.statusCode <= 299;\n}\n\n// We ignore mutable export linting errors because we explicitly want these abstract functions to be overwritten.\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractFetch: AbstractFetchFunc = () => {\n  throw new Error(\n    \"Missing adapter implementation for 'abstractFetch' - make sure to import the appropriate adapter for your platform\",\n  );\n};\nexport function setAbstractFetchFunc(func: AbstractFetchFunc) {\n  abstractFetch = func;\n}\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractConvertRequest: AbstractConvertRequestFunc = () => {\n  throw new Error(\n    \"Missing adapter implementation for 'abstractConvertRequest' - make sure to import the appropriate adapter for your platform\",\n  );\n};\nexport function setAbstractConvertRequestFunc(\n  func: AbstractConvertRequestFunc,\n) {\n  abstractConvertRequest = func;\n}\n\n// By default we just return an empty NormalizedResponse because not all adapters will need to convert an incoming response\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractConvertIncomingResponse: AbstractConvertIncomingResponseFunc =\n  () => Promise.resolve({} as NormalizedResponse);\nexport function setAbstractConvertIncomingResponseFunc(\n  func: AbstractConvertIncomingResponseFunc,\n) {\n  abstractConvertIncomingResponse = func;\n}\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractConvertResponse: AbstractConvertResponseFunc = () => {\n  throw new Error(\n    \"Missing adapter implementation for 'abstractConvertResponse' - make sure to import the appropriate adapter for your platform\",\n  );\n};\nexport function setAbstractConvertResponseFunc(\n  func: AbstractConvertResponseFunc,\n) {\n  abstractConvertResponse = func;\n}\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let abstractConvertHeaders: AbstractConvertHeadersFunc = () => {\n  throw new Error(\n    \"Missing adapter implementation for 'abstractConvertHeaders' - make sure to import the appropriate adapter for your platform\",\n  );\n};\nexport function setAbstractConvertHeadersFunc(\n  func: AbstractConvertHeadersFunc,\n) {\n  abstractConvertHeaders = func;\n}\n"],
  "mappings": "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",
  "names": ["HashFormat"]
}
